#lang racket
(provide (all-defined-out))

(define (make-variable)
  (let ((value 0)
        (grad 0)
        (forward '())
        (backward '()))
    (define (call-each actions)
      (if (null? actions)
          'done
          (begin
            ((car actions))
            (call-each (cdr actions)))))
    (define (set-value! new-value)
      (set! value new-value)
      (call-each forward))

    (define (set-grad! new-grad)
      (set! grad new-grad)
      (call-each backward))
    
    (define (add-forward! proc)
      (set! forward (cons proc forward)))
    (define (add-backward! proc)
      (set! backward (cons proc backward)))
    
    (define (dispatch m)
      (cond ((eq? m 'get-value) value)
            ((eq? m 'get-grad) grad)
            ((eq? m 'set-value!) set-value!)
            ((eq? m 'set-grad!) set-grad!)
            ((eq? m 'add-forward!) add-forward!)
            ((eq? m 'add-backward!) add-backward!)
            (else (display "error"))))
    dispatch))

(define (get-value v)
  (v 'get-value))
(define (get-grad v)
  (v 'get-grad))
(define (set-value! v new-value)
  ((v 'set-value!) new-value))
(define (set-grad! v new-grad)
  ((v 'set-grad!) new-grad))
(define (add-forward! v proc)
  ((v 'add-forward!) proc))
(define (add-backward! v proc)
  ((v 'add-backward!) proc))